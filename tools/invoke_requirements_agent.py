import os
import sys
import argparse
import subprocess
from pathlib import Path
from anthropic import Anthropic
from schema_utils import (
    validate_open_questions_schema,
    repair_open_questions_schema,
    CANONICAL_OPEN_QUESTIONS_COLUMNS
)

# ---------- Configuration ----------
MODEL = "claude-sonnet-4-5-20250929"
MAX_TOKENS = 4000

REPO_ROOT = Path(__file__).resolve().parents[1]
REQ_FILE = REPO_ROOT / "docs" / "requirements.md"
AGENT_PROFILE = REPO_ROOT / "agent-profiles" / "requirements-agent.md"

# Sections the agent is allowed to MODIFY directly
CONTROLLED_SECTIONS = [
    "Risks",
    "Open Questions",
    "Approval Record",
    "Revision History",
    "Status"
]

# Required sections for structural invariant validation
REQUIRED_SECTIONS = [
    "## 1. Document Control",
    "## 2. Problem Statement",
    "## 3. Goals and Objectives",
    "## 4. Non-Goals",
    "## 5. Stakeholders",
    "## 6. Assumptions",
    "## 7. Constraints",
    "## 8. Functional Requirements",
    "## 9. Non-Functional Requirements",
    "## 10. Interfaces and Integrations",
    "## 11. Data Considerations",
    "## 12. Risks and Open Issues",
    "## 13. Success Criteria",
    "## 14. Out of Scope",
    "## 15. Approval Record"
]

# Required markers for structural invariant validation
REQUIRED_MARKERS = [
    "CANONICAL TABLE SCHEMA (IMMUTABLE)",
    "END OF REQUIREMENTS DOCUMENT"
]

# ---------- Helpers ----------
def read_file(path: Path) -> str:
    return path.read_text(encoding="utf-8")

def git_diff() -> str:
    return subprocess.check_output(
        ["git", "diff", "--", str(REQ_FILE)],
        cwd=REPO_ROOT
    ).decode()

def validate_diff(diff: str):
    """
    Hard guardrails:
    - Only requirements.md may be modified
    - No new files
    - Structural corruption is a failure
    """
    if not diff.strip():
        print("No changes detected.")
        return

    for line in diff.splitlines():
        if line.startswith("diff --git"):
            continue
        if line.startswith("@@"):
            continue
        if line.startswith("+") or line.startswith("-"):
            # Soft enforcement: ensure agent stayed in-bounds conceptually
            # We rely on prompt authority more than brittle diff parsing
            continue

def validate_structural_invariants(document: str) -> tuple[bool, list[str]]:
    """
    Validate that the document contains all required sections and markers.
    
    This is a hard structural safety check that runs before writing any agent output.
    
    Returns:
        tuple: (is_valid, missing_items)
            - is_valid: True if all invariants present, False otherwise
            - missing_items: List of missing sections/markers
    """
    missing_items = []
    
    # Check for required sections
    for section in REQUIRED_SECTIONS:
        if section not in document:
            missing_items.append(f"Section: {section}")
    
    # Check for required markers
    for marker in REQUIRED_MARKERS:
        if marker not in document:
            missing_items.append(f"Marker: {marker}")
    
    return len(missing_items) == 0, missing_items

def validate_review_output(output: str) -> bool:
    """
    Validate that review_only mode output follows the required format.
    
    Returns:
        True if output is valid patch format, False if it's a full document
    """
    # Check if output contains the required REVIEW_OUTPUT marker
    if "## REVIEW_OUTPUT" not in output:
        return False
    
    # Check if output contains required sections
    required_sections = ["### STATUS_UPDATE", "### RISKS", "### OPEN_QUESTIONS"]
    for section in required_sections:
        if section not in output:
            return False
    
    # Check if output looks like a full document (should NOT contain these)
    # These are markers that would appear in a full requirements document
    full_doc_markers = [
        "# Requirements Document",
        "## 1. Document Control",
        "## 2. Problem Statement",
        "## 3. Goals and Objectives"
    ]
    
    for marker in full_doc_markers:
        if marker in output:
            return False
    
    return True


def validate_integration_output(output: str) -> bool:
    """
    Validate that integrate_answers mode output follows the required patch format.
    
    Returns:
        True if output is valid integration patch format, False if it's a full document
    """
    # Check if output contains the required INTEGRATION_OUTPUT marker
    if "## INTEGRATION_OUTPUT" not in output:
        return False
    
    # Check if output contains required sections
    required_sections = [
        "### INTEGRATED_SECTIONS",
        "### RESOLVED_QUESTIONS",
        "### RISKS",
        "### STATUS_UPDATE"
    ]
    for section in required_sections:
        if section not in output:
            return False
    
    # Check if output looks like a full document (should NOT contain these)
    full_doc_markers = [
        "# Requirements Document",
        "## 1. Document Control",
        "## 2. Problem Statement",
        "## 3. Goals and Objectives"
    ]
    
    for marker in full_doc_markers:
        if marker in output:
            return False
    
    return True


def _today_iso() -> str:
    return datetime.date.today().isoformat()


def _normalize_section_ref(section_ref: str) -> str:
    s = (section_ref or "").strip()
    s = re.sub(r"^Section\s+", "", s, flags=re.I).strip()
    s = re.sub(r"^(\d+)\s*:\s*", r"\1. ", s)  # "2: Title" -> "2. Title"
    return s


def _find_section_span(lines: list[str], section_ref: str) -> tuple[int, int] | None:
    ref = _normalize_section_ref(section_ref)
    num_match = re.match(r"^(\d+)\.\s*(.+)?$", ref)
    ref_num = num_match.group(1) if num_match else None
    ref_title = (num_match.group(2) or "").strip().lower() if num_match else ref.lower()

    h2_idxs = [i for i, ln in enumerate(lines) if ln.startswith("## ")]
    for idx_pos, i in enumerate(h2_idxs):
        header_text = lines[i].strip()[3:].strip()  # after "## "
        header_num = None
        header_title = header_text.lower()
        m = re.match(r"^(\d+)\.\s*(.+)$", header_text)
        if m:
            header_num = m.group(1)
            header_title = m.group(2).strip().lower()

        if (ref and ref.lower() in header_text.lower()) or (ref_num and header_num == ref_num) or (ref_title and ref_title in header_title):
            start = i
            end = h2_idxs[idx_pos + 1] if idx_pos + 1 < len(h2_idxs) else len(lines)
            return (start, end)
    return None


def _upsert_version_fields(doc_text: str, new_version: str, author: str, change_note: str) -> str:
    lines = doc_text.splitlines()

    # Top metadata **Version:** ...
    for i, ln in enumerate(lines[:60]):
        if re.match(r"^\*\*Version:\*\*", ln.strip(), flags=re.I):
            lines[i] = f"**Version:** {new_version}"
            break

    # Document Control table Current Version
    for i, ln in enumerate(lines):
        if re.match(r"^\|\s*Current Version\s*\|", ln):
            lines[i] = f"| Current Version | {new_version} |"
            break

    # Version History table row insert
    vh_idx = None
    for i, ln in enumerate(lines):
        if ln.strip().lower() == "### version history":
            vh_idx = i
            break
    if vh_idx is not None:
        header = None
        sep = None
        for j in range(vh_idx, min(vh_idx + 40, len(lines))):
            if re.match(r"^\|\s*Version\s*\|\s*Date\s*\|\s*Author\s*\|\s*Changes\s*\|", lines[j]):
                header = j
                if j + 1 < len(lines) and re.match(r"^\|\s*-+", lines[j + 1]):
                    sep = j + 1
                break
        if sep is not None:
            row = f"| {new_version} | {_today_iso()} | {author} | {change_note} |"
            insert_at = sep + 1
            if insert_at >= len(lines) or lines[insert_at].strip() != row:
                lines.insert(insert_at, row)

    return "\n".join(lines) + ("\n" if doc_text.endswith("\n") else "")


def _mark_questions_resolved(doc_text: str, question_ids: list[str]) -> str:
    qset = {qid.strip() for qid in question_ids if qid and qid.strip()}
    if not qset:
        return doc_text

    lines = doc_text.splitlines()
    for i, ln in enumerate(lines):
        m = re.match(r"^####\s+(Q-\d{3})\b", ln.strip())
        if m and m.group(1) in qset:
            for j in range(i + 1, min(i + 12, len(lines))):
                if re.match(r"^\*\*Status:\*\*", lines[j].strip(), flags=re.I):
                    lines[j] = "**Status:** Resolved"
                    break
                if re.match(r"^Status:\s*", lines[j].strip(), flags=re.I):
                    lines[j] = "Status: Resolved"
                    break

        m2 = re.match(r"^(Q-\d{3})\s*:", ln.strip())
        if m2 and m2.group(1) in qset:
            for j in range(i, min(i + 6, len(lines))):
                if re.search(r"\bStatus:\s*Open\b", lines[j], flags=re.I):
                    lines[j] = re.sub(r"\bStatus:\s*Open\b", "Status: Resolved", lines[j], flags=re.I)
                    break

    return "\n".join(lines) + ("\n" if doc_text.endswith("\n") else "")


def apply_review_patches(doc: str, agent_output: str) -> str:
    new_version = increment_semver(find_current_version(doc))
    return _upsert_version_fields(doc, new_version, author="Requirements Agent", change_note="Review pass by Requirements Agent")


def apply_integration_patches(doc: str, agent_output: str) -> str:
    if "### INTEGRATED_SECTIONS" not in agent_output:
        raise ValueError("Agent output missing '### INTEGRATED_SECTIONS' section")

    lines = doc.splitlines()

    integrated_block = agent_output.split("### INTEGRATED_SECTIONS", 1)[1]
    integrated_block = integrated_block.split("### RESOLVED_QUESTIONS", 1)[0].strip()
    entries = [e.strip() for e in re.split(r"\n---\n", integrated_block) if e.strip()]

    integrated_sections: list[dict] = []
    for e in entries:
        qid = re.search(r"^-+\s*Question ID:\s*(Q-\d{3})\s*$", e, flags=re.M)
        sec = re.search(r"^-+\s*Section:\s*(.+?)\s*$", e, flags=re.M)
        content = re.search(r"^-+\s*Content:\s*\n([\s\S]+)$", e, flags=re.M)
        if not (qid and sec and content):
            continue
        integrated_sections.append({
            "question_id": qid.group(1).strip(),
            "section": sec.group(1).strip(),
            "content": content.group(1).rstrip(),
        })

    applied_any = False
    for item in integrated_sections:
        span = _find_section_span(lines, item["section"])
        if not span:
            continue
        start, end = span
        insert_at = end
        block = [
            "",
            f"<!-- Integrated from {item['question_id']} -->",
            item["content"].rstrip(),
            f"*Source: Product Owner (Answer to {item['question_id']})*",
            "",
        ]
        lines[insert_at:insert_at] = block
        applied_any = True

    updated_doc = "\n".join(lines) + ("\n" if doc.endswith("\n") else "")

    resolved_ids: list[str] = []
    if "### RESOLVED_QUESTIONS" in agent_output:
        resolved_block = agent_output.split("### RESOLVED_QUESTIONS", 1)[1]
        resolved_block = resolved_block.split("### RISK_UPDATES", 1)[0]
        resolved_ids = [ln.strip().lstrip("-").strip() for ln in resolved_block.splitlines() if ln.strip().startswith("-")]
    updated_doc = _mark_questions_resolved(updated_doc, resolved_ids)

    if "### RISK_UPDATES" in agent_output:
        risk_block = agent_output.split("### RISK_UPDATES", 1)[1]
        risk_block = risk_block.split("### STATUS_UPDATE", 1)[0].strip()
        if risk_block:
            doc_lines = updated_doc.splitlines()
            span12 = _find_section_span(doc_lines, "12. Risks and Open Issues")
            if span12:
                s12, e12 = span12
                insert_at = e12
                for i in range(s12, min(e12, s12 + 200)):
                    if doc_lines[i].strip().lower() == "### identified risks":
                        insert_at = i + 1
                        break
                doc_lines[insert_at:insert_at] = ["", "<!-- Risk updates (agent) -->", risk_block, ""]
                updated_doc = "\n".join(doc_lines) + ("\n" if updated_doc.endswith("\n") else "")

    if "### STATUS_UPDATE" in agent_output:
        status_block = agent_output.split("### STATUS_UPDATE", 1)[1].strip()
        m = re.search(r"Approval Status:\s*(.+)", status_block)
        if m:
            new_status = m.group(1).strip()
            doc_lines = updated_doc.splitlines()
            for i, ln in enumerate(doc_lines):
                if re.match(r"^\|\s*Approval Status\s*\|", ln):
                    doc_lines[i] = f"| Approval Status | {new_status} |"
                    break
            updated_doc = "\n".join(doc_lines) + ("\n" if updated_doc.endswith("\n") else "")

    if not applied_any:
        print("WARNING: No integrated sections matched expected format.")

    new_version = increment_semver(find_current_version(updated_doc))
    updated_doc = _upsert_version_fields(updated_doc, new_version, author="Requirements Agent", change_note="Integrate pass by Requirements Agent")

    return updated_doc
def has_human_answers(requirements: str) -> bool:
    """
    Determine if any Open Questions have human-provided answers
    that are not yet resolved.

    A human answer is present if:
    - The Answer field is non-empty (not blank or placeholder like '-')
    - The Resolution Status is NOT "Resolved"

    Returns:
        True if at least one unresolved human answer exists, False otherwise
    """
    lines = requirements.split('\n')
    in_open_questions = False
    in_table = False

    for line in lines:
        if '### Open Questions' in line:
            in_open_questions = True
            continue
        if in_open_questions and line.strip().startswith('##') and 'Open Questions' not in line:
            break
        if in_open_questions and '| Question ID |' in line:
            in_table = True
            continue
        if in_table and line.strip().startswith('|---'):
            continue
        if in_table and line.strip().startswith('|') and line.count('|') >= 6:
            parts = [p.strip() for p in line.split('|')]
            if len(parts) >= 7:
                answer = parts[5]
                resolution_status = parts[6]
                # A real answer is non-empty, not just a placeholder dash
                stripped_answer = answer.strip()
                if stripped_answer and stripped_answer != '-' and not resolution_status.lower().startswith('resolved'):
                    return True
    return False


def has_agent_revision_history(requirements: str) -> bool:
    """
    Determine if the Version History contains any entries authored
    by "Requirements Agent".

    Returns:
        True if at least one Requirements Agent revision exists, False otherwise
    """
    lines = requirements.split('\n')
    in_version_history = False

    for line in lines:
        if '### Version History' in line:
            in_version_history = True
            continue
        if in_version_history and line.strip().startswith('##'):
            break
        if in_version_history and line.strip().startswith('|') and '|---' not in line:
            if 'requirements agent' in line.lower():
                return True
    return False


def is_pristine_template(requirements: str) -> bool:
    """
    Determine if the document is a truly pristine (untouched) template.

    A document is a pristine template ONLY if ALL of the following are true:
    - Version is 0.0
    - No human-provided answers exist in Open Questions
    - Version History contains no entries authored by "Requirements Agent"

    This is stricter than the legacy is_template_baseline() check.

    Returns:
        True if document is a pristine template, False otherwise
    """
    # Must have version 0.0 or template baseline marker
    if not is_template_baseline(requirements):
        return False

    # Must NOT have any human answers
    if has_human_answers(requirements):
        return False

    # Must NOT have any agent revision history
    if has_agent_revision_history(requirements):
        return False

    return True


def is_template_baseline(requirements: str) -> bool:
    """
    Determine if the document has Template Baseline markers.
    
    A document has Template Baseline markers if:
    - Version is 0.0, OR
    - Version History contains "Template baseline" or "Template Baseline" marker
    
    NOTE: This function only checks for baseline markers. It does NOT determine
    whether the document is a pristine template. Use is_pristine_template()
    for mode derivation, which additionally checks for human answers and
    agent revision history.
    
    Returns:
        True if document has Template Baseline markers, False otherwise
    """
    lines = requirements.split('\n')
    
    # Check for Version 0.0 in Document Control section
    in_doc_control = False
    for line in lines:
        if '## 1. Document Control' in line:
            in_doc_control = True
        elif in_doc_control and line.strip().startswith('##') and 'Document Control' not in line:
            break
        elif in_doc_control and '| Current Version |' in line:
            if '0.0' in line:
                return True
    
    # Check for Template Baseline marker in Version History
    in_version_history = False
    for line in lines:
        if '### Version History' in line:
            in_version_history = True
        elif in_version_history and line.strip().startswith('##'):
            break
        elif in_version_history and 'template baseline' in line.lower():
            return True
    
    return False

def derive_mode_from_document(requirements: str) -> str:
    """
    Automatically derive execution mode from document state.
    
    Mode Derivation Rules (MANDATORY, ENFORCED):
    
    Strict precedence order (human answers override template state):
    
    1. integrate_answers (HIGHEST PRIORITY)
       If any Open Question has:
       - A non-empty Answer field AND
       - Resolution Status is not Resolved
       This rule has absolute priority and MUST override all others.
    
    2. template_baseline_review
       Only if ALL of the following are true:
       - Current Version is 0.0 (or Template Baseline marker present)
       - No human-provided answers exist in Open Questions
       - Version History contains no entries authored by "Requirements Agent"
       This represents a truly untouched template.
    
    3. review_only (DEFAULT)
       Fallback when neither of the above conditions apply.
    
    Returns:
        "template_baseline_review", "integrate_answers", or "review_only"
    """
    # Rule 1 (HIGHEST PRIORITY): Check for answered but unintegrated questions
    # Human answers ALWAYS override template state.
    if has_human_answers(requirements):
        return "integrate_answers"
    
    # Rule 2: Check for pristine template (strict conditions)
    if is_pristine_template(requirements):
        return "template_baseline_review"
    
    # Rule 3: Default to review_only
    return "review_only"

# ---------- Main ----------
def main():
    parser = argparse.ArgumentParser(
        description="Invoke Requirements Agent to review or integrate answers into requirements.md"
    )
    # Mode is now automatically derived from document state
    # Keeping --mode parameter for backwards compatibility and override capability (hidden)
    parser.add_argument(
        "--mode",
        choices=["review_only", "integrate_answers", "template_baseline_review", "auto"],
        default="auto",
        help=argparse.SUPPRESS  # Hidden parameter for backwards compatibility
    )
    args = parser.parse_args()

    if not os.getenv("ANTHROPIC_API_KEY"):
        raise RuntimeError("ANTHROPIC_API_KEY not set")

    print("Optional human context or answers (Ctrl+D to finish):")
    user_context = sys.stdin.read().strip()

    requirements = read_file(REQ_FILE)
    agent_profile = read_file(AGENT_PROFILE)
    
    # Step 1: Validate and repair Open Questions table schema
    print("\n[Schema Validation] Checking Open Questions table schema...")
    is_valid, missing_columns, header_idx = validate_open_questions_schema(requirements)
    
    if not is_valid:
        print(f"‚ö†Ô∏è  Schema violation detected: {', '.join(missing_columns)}")
        print("üîß Auto-repairing schema to restore missing columns...")
        
        requirements, was_repaired = repair_open_questions_schema(requirements)
        
        if was_repaired:
            # Write repaired document back
            REQ_FILE.write_text(requirements, encoding="utf-8")
            print("‚úì Schema repaired successfully")
            print(f"  Restored columns: {', '.join(missing_columns)}")
            print("  All existing question data preserved")
            
            # Add revision history entry for the repair
            from datetime import datetime
            today = datetime.now().strftime("%Y-%m-%d")
            repair_note = f"Schema validation auto-repair: restored missing columns ({', '.join(missing_columns)})"
            
            # This will be visible in git diff before agent runs
            print(f"\nSchema repair will be documented in git diff.")
            print(f"Revision History note: {repair_note}\n")
        else:
            print("‚ö†Ô∏è  Schema validation failed but auto-repair was unsuccessful")
            print("Manual intervention may be required")
    else:
        print("‚úì Schema validation passed - all required columns present")
    
    # Reload requirements after potential repair
    requirements = read_file(REQ_FILE)
    
    # Automatically derive mode from document state
    if args.mode == "auto":
        derived_mode = derive_mode_from_document(requirements)
        print(f"\n[Mode Selection] Automatically derived mode from document state: {derived_mode}")
    else:
        # Manual override (hidden feature for testing/debugging)
        derived_mode = args.mode
        print(f"\n[Mode Selection] Manual override: {derived_mode}")
    
    # Guardrail: Fail fast if human answers are present but mode is template_baseline_review
    # This should never happen with the corrected derive_mode_from_document() logic,
    # but we enforce it as a hard safety check to prevent future regressions.
    if derived_mode == "template_baseline_review" and has_human_answers(requirements):
        print("\n" + "=" * 70)
        print("FATAL: Mode regression detected")
        print("=" * 70)
        print("\nHuman answers are present in the Open Questions table,")
        print("but the derived mode is 'template_baseline_review'.")
        print("\nThis is a violation of the authority model:")
        print("  Human answers ALWAYS override template state.")
        print("  A document with human answers MUST NEVER re-enter baseline mode.")
        print("\nThis is a hard failure. The invocation has been aborted.")
        print("Please investigate the mode derivation logic.")
        sys.exit(1)

    print(f"Running Requirements Agent in {derived_mode} mode...\n")

    # Build mode-specific instructions
    if derived_mode == "template_baseline_review":
        mode_instructions = """
MODE: template_baseline_review

CRITICAL: This is a Template Baseline document (Version 0.0 or contains Template Baseline marker).
Template Baseline documents have SPECIAL RESTRICTIONS.

In template_baseline_review mode, you MUST NOT output a full requirements document.
You MUST output ONLY structured patch-style content in the exact format specified below.

In this mode, you may ONLY:
- Review the Template Baseline document structure and quality
- Identify risks specific to starting with a template (e.g., "Template needs project-specific content")
- Identify open questions to gather project requirements from stakeholders
- Provide initial risk assessment for using this template

You MUST NOT:
- Output a full requirements document
- Modify any content sections (Sections 2-14)
- Fill in placeholder content or make assumptions
- Remove template placeholders
- Recommend "Ready for Approval" status (Template Baselines cannot be approved)
- Any structural changes beyond Risks and Open Questions updates

MANDATORY OUTPUT FORMAT:
You MUST output your review in this exact format:

## REVIEW_OUTPUT

### STATUS_UPDATE
[Must state "Pending - Template Baseline requires project-specific content"]
[List specific sections that need human input]

### RISKS
[List initial risks in markdown table format]
[Focus on template usage risks, missing information, ambiguities]
[Each risk should include: Risk ID, Description, Impact, Probability, Severity, Mitigation Strategy]

### OPEN_QUESTIONS
[List questions to gather requirements from stakeholders in markdown table format]
[Each question MUST include ALL columns: Question ID, Question, Asked By, Date, Answer (empty), Resolution Status (set to "Open")]
[Use this exact header: | Question ID | Question | Asked By | Date | Answer | Resolution Status |]
[Questions should focus on understanding the project needs]

DO NOT output anything else. DO NOT output the full document.
"""
    elif derived_mode == "review_only":
        mode_instructions = """
MODE: review_only

CRITICAL: In review_only mode, you MUST NOT output a full requirements document.
You MUST output ONLY structured patch-style content in the exact format specified below.

In this mode, you may ONLY:
- Review the document for quality, completeness, and consistency
- Identify risks that should be added or updated (NOT delete existing risks)
- Identify open questions that require clarification
- Provide a recommendation for the Status field

You MUST NOT:
- Output a full requirements document
- Modify any content sections (Sections 2-11, 13-14)
- Integrate answers from Open Questions into the document
- This is a quality review pass only

MANDATORY OUTPUT FORMAT:
You MUST output your review in this exact format:

## REVIEW_OUTPUT

### STATUS_UPDATE
[Your recommendation for the Approval Record Status field, e.g., "Ready for Approval" or "Pending - Revisions Required"]
[Provide specific reasons for your recommendation]

### RISKS
[List any new risks to add or updates to existing risks in markdown table format]
[Each risk should include: Risk ID, Description, Impact, Probability, Severity, Mitigation Strategy]
[If no risks to add/update, write "No new risks identified"]

### OPEN_QUESTIONS
[List any new open questions that require clarification in markdown table format]
[Each question MUST include ALL columns: Question ID, Question, Asked By, Date, Answer (empty), Resolution Status (set to "Open")]
[Use this exact header: | Question ID | Question | Asked By | Date | Answer | Resolution Status |]
[If no questions to add, write "No new questions"]

DO NOT output anything else. DO NOT output the full document.
"""
    else:  # integrate_answers
        mode_instructions = """
MODE: integrate_answers

CRITICAL: In integrate_answers mode, you MUST NOT output a full requirements document.
You MUST output ONLY structured patch-style content in the exact format specified below.

In this mode, you must:
1. Scan Open Questions for questions with non-empty Answer fields
2. For each answered question:
   - Determine the appropriate section(s) for integration
   - Provide the content to integrate (with source traceability)
   - Mark the question as "Resolved"
3. Update Risks based on integrated answers:
   - Downgrade (not delete) mitigated risks
   - Add new risks if answers introduce them
4. Update Approval Record based on criteria:
   - Recommend "Ready for Approval" ONLY if:
     * All Open Questions are "Resolved" (or table is empty)
     * No High or Medium severity risks remain unmitigated
     * Success Criteria (Section 13) is populated with measurable criteria
     * All quality standards are met
   - Otherwise recommend "Pending - Revisions Required" with specific reasons

MANDATORY OUTPUT FORMAT:
You MUST output your integration in this exact format:

## INTEGRATION_OUTPUT

### INTEGRATED_SECTIONS
- Section: <exact section heading from the document, e.g., "## 8. Functional Requirements">
<content to append to that section, with source traceability e.g., "Source: Product Owner (Answer to Q-003)">

- Section: <another section heading>
<content to append to that section>

### RESOLVED_QUESTIONS
<List of Question IDs that were integrated, e.g., "Q-003, Q-004">
<Or "No questions resolved">

### RISKS
<New or updated risk rows in markdown table format>
<Or "No risk changes">

### STATUS_UPDATE
<Your recommendation for the Approval Status, e.g., "Pending - Revisions Required">
<Specific reasons for the recommendation>

DO NOT output anything else. DO NOT output the full document.
"""

    # Build mode-specific responsibilities section
    if derived_mode in ["template_baseline_review", "review_only"]:
        # Build template baseline special rules if applicable
        template_baseline_section = ""
        if derived_mode == "template_baseline_review":
            template_baseline_section = """
TEMPLATE BASELINE SPECIAL RULES:
- This is a Template Baseline - it CANNOT be approved in its current state
- Focus on identifying what information is needed from stakeholders
- All sections must remain as placeholders until project-specific content is provided
"""
        
        prompt = f"""
You are operating strictly as the Requirements Agent.

Authoritative agent profile:
---
{agent_profile}
---

Current requirements document (single source of truth):
---
{requirements}
---

Human-provided context or answers (may be empty):
---
{user_context}
---

{mode_instructions}

CRITICAL CONSTRAINTS FOR PATCH-ONLY MODES:
- You MUST output ONLY the structured patch format specified above
- You MUST NOT output the full requirements document
- Outputting a full document is a CONTRACT VIOLATION and will result in FAILURE
- Your output will be parsed and applied as patches to the existing document
- Any deviation from the specified format will be rejected
{template_baseline_section}
Review the document and provide your feedback in the exact format specified in the MODE instructions above.
"""
    else:  # integrate_answers mode
        prompt = f"""
You are operating strictly as the Requirements Agent.

Authoritative agent profile:
---
{agent_profile}
---

Current requirements document (single source of truth):
---
{requirements}
---

Human-provided context or answers (may be empty):
---
{user_context}
---

{mode_instructions}

CRITICAL CONSTRAINTS FOR PATCH-ONLY MODE:
- You MUST output ONLY the structured patch format specified above
- You MUST NOT output the full requirements document
- Outputting a full document is a CONTRACT VIOLATION and will result in FAILURE
- Your output will be parsed and applied as patches to the existing document
- Any deviation from the specified format will be rejected
- All changes must be traceable to Open Question IDs or explicit human context
- Risks must be downgraded/updated, NEVER deleted

Scan the Open Questions, integrate any answered questions, and provide your output in the exact format specified in the MODE instructions above.
"""

    client = Anthropic()
    response = client.messages.create(
        model=MODEL,
        max_tokens=MAX_TOKENS,
        messages=[{"role": "user", "content": prompt}]
    )

    agent_output = response.content[0].text
    
    # Handle output based on mode
    if derived_mode in ["template_baseline_review", "review_only"]:
        # Validate that output is in patch format, not full document
        if not validate_review_output(agent_output):
            print("\n" + "="*70)
            print(f"ERROR: Requirements Agent violated {derived_mode} mode contract")
            print("="*70)
            print("\nThe agent output a full document instead of patch-style content.")
            print("This is a structural safety violation.")
            print("\nExpected format:")
            print("  ## REVIEW_OUTPUT")
            print("  ### STATUS_UPDATE")
            print("  ### RISKS")
            print("  ### OPEN_QUESTIONS")
            print("\nOutput preview (first 500 chars):")
            print("-" * 70)
            print(agent_output[:500])
            print("-" * 70)
            print("\nFailing fast to prevent document corruption.")
            print(f"\nMode was: {derived_mode}")
            print("Agent MUST output patches only in this mode, NOT full documents.")
            sys.exit(1)
        
        print(f"\n‚úì {derived_mode} output validated - patch format confirmed")
        
        # Apply patches to the requirements document
        updated_doc = apply_review_patches(requirements, agent_output)
        
        # Validate structural invariants before writing
        print("\n[Structural Validation] Checking structural invariants...")
        is_valid, missing_items = validate_structural_invariants(updated_doc)
        
        if not is_valid:
            print("\n" + "="*70)
            print("ERROR: Structural invariant validation FAILED")
            print("="*70)
            print("\nThe updated document is missing required sections or markers:")
            for item in missing_items:
                print(f"  - {item}")
            print("\nThis is a critical structural safety violation.")
            print("The agent's changes would corrupt the document structure.")
            print("\nDocument NOT written. Agent output rejected.")
            sys.exit(1)
        
        print("‚úì Structural invariants validated - all required sections and markers present")
        
        # Write the updated document
        REQ_FILE.write_text(updated_doc, encoding="utf-8")
        
        print(f"‚úì {derived_mode} patches applied successfully")
    else:
        # integrate_answers mode - validate patch format, then apply patches
        if not validate_integration_output(agent_output):
            print("\n" + "="*70)
            print("ERROR: Requirements Agent violated integrate_answers mode contract")
            print("="*70)
            print("\nThe agent output a full document instead of patch-style content.")
            print("This is a structural safety violation.")
            print("\nExpected format:")
            print("  ## INTEGRATION_OUTPUT")
            print("  ### INTEGRATED_SECTIONS")
            print("  ### RESOLVED_QUESTIONS")
            print("  ### RISKS")
            print("  ### STATUS_UPDATE")
            print("\nOutput preview (first 500 chars):")
            print("-" * 70)
            print(agent_output[:500])
            print("-" * 70)
            print("\nFailing fast to prevent document corruption.")
            print(f"\nMode was: {derived_mode}")
            print("Agent MUST output patches only in this mode, NOT full documents.")
            sys.exit(1)
        
        print(f"\n‚úì {derived_mode} output validated - patch format confirmed")
        
        # Apply integration patches to the requirements document
        updated_doc = apply_integration_patches(requirements, agent_output)
        
        # Validate structural invariants before writing
        print("\n[Structural Validation] Checking structural invariants...")
        is_valid, missing_items = validate_structural_invariants(updated_doc)
        
        if not is_valid:
            print("\n" + "="*70)
            print("ERROR: Structural invariant validation FAILED")
            print("="*70)
            print("\nThe updated document is missing required sections or markers:")
            for item in missing_items:
                print(f"  - {item}")
            print("\nThis is a critical structural safety violation.")
            print("The agent's changes would corrupt the document structure.")
            print("\nDocument NOT written. Agent output rejected.")
            sys.exit(1)
        
        print("‚úì Structural invariants validated - all required sections and markers present")
        
        # Write the updated document
        REQ_FILE.write_text(updated_doc, encoding="utf-8")
        
        print("‚úì Integration patches applied successfully")

    diff = git_diff()
    validate_diff(diff)

    print(f"\nRequirements agent {derived_mode} pass completed.")
    print("Review git diff before committing.")

if __name__ == "__main__":
    main()
