# Section Handler Registry
# Maps (doc_type, section_id) -> handler configuration
# This decouples section processing logic from code, allowing new document types
# and section behaviors to be defined via YAML configuration without engine changes.

# Handler Modes:
#   - integrate_then_questions: Default mode (current phase1/phase2 behavior)
#       * If section has answered questions → integrate answers via LLM
#       * If section still blank after integration → generate new questions
#       * If section has open questions but no answers → skip (blocked)
#   - questions_then_integrate: Alternative mode (future use)
#       * If section blank and no questions → generate questions
#       * If section has answered questions → integrate answers
#       * Never generate questions after integration (single pass)
#   - review_gate: Special mode for review gates (Issue 7)
#       * LLM reviews specified scope (prior sections or current)
#       * Returns pass/fail + optional patches
#       * No direct document mutation

# Output Formats:
#   - prose: Paragraph format (default)
#   - bullets: Bullet list format
#   - subsections: Preserve subsection headers (e.g., ### Technical Constraints)

# Scope Values:
#   - current_section: Process/review only the current section
#   - all_prior_sections: Review all sections before this gate (for review_gate mode)

# Handler definitions for requirements document type
requirements:
  problem_statement:
    mode: integrate_then_questions
    output_format: prose
    subsections: false
    dedupe: false
    preserve_headers: []
    sanitize_remove: []
    llm_profile: requirements
    auto_apply_patches: never
    scope: current_section
    
  goals_objectives:
    mode: integrate_then_questions
    output_format: bullets
    subsections: true  # supports primary_goals, secondary_goals, non_goals
    dedupe: false
    preserve_headers: []
    sanitize_remove: []
    llm_profile: requirements
    auto_apply_patches: never
    scope: all_prior_sections  # Use prior context to inform questions
    
  stakeholders_users:
    mode: integrate_then_questions
    output_format: prose
    subsections: false
    dedupe: false
    preserve_headers: []
    sanitize_remove: []
    llm_profile: requirements
    auto_apply_patches: never
    scope: all_prior_sections  # Use prior context to inform questions
    
  success_criteria:
    mode: integrate_then_questions
    output_format: bullets
    subsections: false
    dedupe: false
    preserve_headers: []
    sanitize_remove: []
    llm_profile: requirements
    auto_apply_patches: never
    scope: all_prior_sections  # Use prior context to inform questions
    
  assumptions:
    mode: integrate_then_questions
    output_format: bullets
    subsections: false
    dedupe: true  # remove duplicate assumptions after integration
    preserve_headers: []
    sanitize_remove:
      - "constraint classification headers"
    llm_profile: requirements
    auto_apply_patches: never
    scope: all_prior_sections  # Use prior context to inform questions
    
  constraints:
    mode: integrate_then_questions
    output_format: subsections  # preserve ### Technical/Operational/Resource Constraints
    subsections: false
    dedupe: false
    preserve_headers:
      - "### Technical Constraints"
      - "### Operational Constraints"
      - "### Resource Constraints"
    sanitize_remove: []
    llm_profile: requirements
    auto_apply_patches: never
    scope: all_prior_sections  # Use prior context to inform questions
    
  requirements:
    mode: integrate_then_questions
    output_format: prose
    subsections: false
    dedupe: false
    preserve_headers: []
    sanitize_remove: []
    llm_profile: requirements
    auto_apply_patches: never
    scope: all_prior_sections
    
  interfaces_integrations:
    mode: integrate_then_questions
    output_format: prose
    subsections: false
    dedupe: false
    preserve_headers: []
    sanitize_remove: []
    llm_profile: requirements
    auto_apply_patches: never
    scope: all_prior_sections
    
  data_considerations:
    mode: integrate_then_questions
    output_format: prose
    subsections: false
    dedupe: false
    preserve_headers: []
    sanitize_remove: []
    llm_profile: requirements
    auto_apply_patches: never
    scope: all_prior_sections
    
  risks_open_issues:
    mode: integrate_then_questions
    output_format: prose
    subsections: false
    dedupe: false
    preserve_headers: []
    sanitize_remove: []
    llm_profile: requirements
    auto_apply_patches: never
    scope: all_prior_sections
    
  approval_record:
    mode: integrate_then_questions
    output_format: prose
    subsections: false
    dedupe: false
    preserve_headers: []
    sanitize_remove: []
    llm_profile: requirements
    auto_apply_patches: never
    scope: current_section
  
  # Review gate example (for Issue 7 implementation)
  review_gate:coherence_check:
    mode: review_gate
    output_format: prose
    subsections: false
    dedupe: false
    preserve_headers: []
    sanitize_remove: []
    llm_profile: requirements_review
    auto_apply_patches: never  # configurable: "never", "always", "if_validation_passes"
    scope: all_prior_sections  # review all sections before this gate
    validation_rules:
      - no_contradictions
      - no_missing_critical_sections
      - consistent_terminology
  
  review_gate:final_review:
    mode: review_gate
    output_format: prose
    subsections: false
    dedupe: false
    preserve_headers: []
    sanitize_remove: []
    llm_profile: requirements_review
    auto_apply_patches: never
    scope: all_prior_sections
    validation_rules:
      - no_contradictions
      - no_missing_critical_sections
      - consistent_terminology
      - requirements_traceable
      - risks_identified

# Default handler for unknown sections
_default:
  requirements:
    mode: integrate_then_questions
    output_format: prose
    subsections: false
    dedupe: false
    preserve_headers: []
    sanitize_remove: []
    llm_profile: requirements
    auto_apply_patches: never
    scope: current_section
